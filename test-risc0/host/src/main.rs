// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use clap::Parser;
use groth16::has_json_repr::load_json;
use groth16::has_primitive_repr::HasPrimitiveRepr;
use groth16::{Inputs, Proof, VerifyingKey};
use methods::{RISC0_GROTH16_AGGREGATION_ELF, RISC0_GROTH16_AGGREGATION_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, ProverOpts};
use std::fs::File;
use std::io::Write;
use std::time::Instant;

const SAMPLE_INPUTS_FILE: &str = "../groth16/src/data/inputs.json";
const SAMPLE_PROOF_FILE: &str = "../groth16/src/data/proof.json";
const SAMPLE_VK_FILE: &str = "../groth16/src/data/vk.json";

/// The arguments for the prove command.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct ProveArgs {
    /// Batch size
    #[clap(long, default_value = "1")]
    n: u32,
}

fn main() {
    println!("ZKVM: RiscZero, no precompiles");
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Read input from JSON
    let inputs: Inputs = load_json(SAMPLE_INPUTS_FILE);
    let proof: Proof = load_json(SAMPLE_PROOF_FILE);
    let groth16_vk: VerifyingKey = load_json(SAMPLE_VK_FILE);

    // Parse batch size from command line
    let args = ProveArgs::parse();
    let batch_size: u32 = args.n;
    println!("Batch size: {batch_size}");

    let env = ExecutorEnv::builder()
        .write(&batch_size)
        .unwrap()
        .write(&inputs.to_repr())
        .unwrap()
        .write(&proof.to_repr())
        .unwrap()
        .write(&groth16_vk.to_repr())
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();
    // Produce a G16 proof, for on-chain verification
    let prover_opts = ProverOpts::groth16();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let now = Instant::now();
    let prove_info = prover
        .prove_with_opts(env, RISC0_GROTH16_AGGREGATION_ELF, &prover_opts)
        .unwrap();
    println!("Proof generation time: {}s", now.elapsed().as_secs());

    // extract the receipt.
    let receipt = prove_info.receipt;

    // Save the proof to a file.
    let filename = format!("./_test_data/risc0_agg_proof_batch_size_{}.g16", batch_size);
    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    let mut file = File::create(&filename).unwrap();
    file.write_all(&receipt_bytes).unwrap();
    println!("Proof saved to file: {}", filename);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(RISC0_GROTH16_AGGREGATION_ID).unwrap();
}
